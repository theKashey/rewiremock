import {expect} from 'chai';

import rewiremock, {addPlugin} from '../src/index';
import sinon from 'sinon';

import nodePlugin from '../src/plugins/nodejs';
import relativePlugin from '../src/plugins/relative';
import aliasPlugin, {configure as configureWebpackAlias} from '../src/plugins/webpack-alias';

describe('rewiremock ', () => {
  describe('overloads ', () => {
    it('should not overload: ', () => {
      rewiremock('./lib/a/foo')
        .with(() => 'aa');

      rewiremock('./lib/a/../b/bar')
        .with(() => 'bb');

      rewiremock('./lib/a/../b/baz')
        .with(() => 'cc');

      const unmockedBaz = require('./lib/a/test.js');
      expect(unmockedBaz()).to.be.equal('foobarbaz');

      rewiremock.enable();

      const mockedBaz = require('./lib/a/test.js');
      expect(mockedBaz()).to.be.equal('foobarbaz');
      rewiremock.disable();
    });

    it('should overload with node plugin: ', () => {
      rewiremock.inScope(() => {
        addPlugin(nodePlugin);
        rewiremock('./lib/a/foo')
          .with(() => 'aa');

        rewiremock('./lib/a/../b/bar')
          .with(() => 'bb');

        rewiremock('./lib/a/../b/baz')
          .with(() => 'cc');

        const unmockedBaz = require('./lib/a/test.js');
        expect(unmockedBaz()).to.be.equal('foobarbaz');

        rewiremock.enable();

        const mockedBaz = require('./lib/a/test.js');
        expect(mockedBaz()).to.be.equal('aabbcc');
        rewiremock.disable();
      });
    });

    it('should overload with relative plugin: ', () => {
      rewiremock.inScope(() => {
        addPlugin(relativePlugin);
        rewiremock('./foo')
          .with(() => 'aa');

        rewiremock('../b/bar')
          .with(() => 'bb');

        rewiremock('../b/baz')
          .with(() => 'cc');

        const unmockedBaz = require('./lib/a/test.js');
        expect(unmockedBaz()).to.be.equal('foobarbaz');

        rewiremock.enable();

        const mockedBaz = require('./lib/a/test.js');
        expect(mockedBaz()).to.be.equal('aabbcc');
        rewiremock.disable();
      });
    });

    it('should overload with webpack alias plugin: ', () => {
      rewiremock.inScope(() => {
        configureWebpackAlias('_tests/webpack.config.js');

        addPlugin(aliasPlugin);
        rewiremock('my-absolute-test-lib/foo')
          .with(() => 'aa');

        rewiremock('same-folder-lib/bar')
          .with(() => 'bb');

        rewiremock('../b/baz')
          .with(() => 'cc');

        const unmockedBaz = require('./lib/a/test.js');
        expect(unmockedBaz()).to.be.equal('foobarbaz');

        rewiremock.enable();

        const mockedBaz = require('./lib/a/test.js');
        expect(mockedBaz()).to.be.equal('aabbcc');
        rewiremock.disable();
      });
    });
  });

  describe('mocking ', () => {
    it('should replace one module by another: ', () => {
      return rewiremock.around(() => require('./lib/a/test.js'),
        () => {
          addPlugin(relativePlugin);
          rewiremock('./foo').by('./foo2');
        })
        .then(mocked => expect(mocked()).to.be.equal('FOObarbaz'));
    });

    it('should replace unexisting file: ', () => {
      rewiremock.inScope(() => {
        rewiremock('./random-file.js').with(42);
        rewiremock.enable();
        expect(require('./random-file')).to.be.equal(42);
        expect(() => require('./another-random-file')).to.throw();
        rewiremock.disable();
        expect(() => require('./random-file')).to.throw();
      });
    });

    it('should handle default: ', () => {
      rewiremock.inScope(() => {
        //addPlugin(relativePlugin);

        const withoutDefault = rewiremock.proxy('./lib/a/getTest.js', {
          './test': {noDefault: 42}
        });
        expect(withoutDefault.noDefault).to.be.equal(42);
        expect(Object.keys(withoutDefault)).to.be.deep.equal(['noDefault']);
        expect(withoutDefault.default).to.be.deep.equal({noDefault: 42});

        const withDefault = rewiremock.proxy('./lib/a/getTest.js', {
          './test': {default: 42}
        });
        expect(withDefault.default).to.be.equal(42);
        expect(Object.keys(withDefault)).to.be.deep.equal(['default']);
      });
    });

    it('should replace one module by autogenerated one: ', () => {
      let toched = false;
      return rewiremock.around(() => require('./lib/a/test.js'),
        () => {
          addPlugin(relativePlugin);

          rewiremock('./foo').by(({name}) => {
            toched = name;
            return () => "FOO";
          });
          expect(toched).to.be.false;
        })
        .then(mocked => {
          expect(mocked()).to.be.equal('FOObarbaz');
        });
    });

    it('should replace one module by autogenerated one with callThougth: ', () => {
      return rewiremock.around(() => require('./lib/a/test.js'),
        () => {
          addPlugin(relativePlugin);

          rewiremock('./foo')
            .callThrough()
            .by(({original}) => {
              return () => "~" + original() + '~'
            });
        })
        .then(mocked => expect(mocked()).to.be.equal('~foo~barbaz'));
    });

    it('should replace one module by autogenerated one with requireActual: ', () => {
      return rewiremock.around(() => require('./lib/a/test.js'),
        () => {
          addPlugin(relativePlugin);

          rewiremock('./foo')
            .by(({requireActual}) => {
              return () => "~" + requireActual('./foo.js')() + '~'
            });
        })
        .then(mocked => expect(mocked()).to.be.equal('~foo~barbaz'));
    });
  });

  describe('direct child ', () => {
    it('should mock any level entity: ', () => {
      return rewiremock.around(() => require('./lib/c/barbaz.js'),
        () => {
          rewiremock('./baz')
            .with(() => 'mock');
        })
        .then(mocked => expect(mocked()).to.be.equal('>+mockmock'));
    });

    it('should mock top level entity only: ', () => {
      return rewiremock.around(() => require('./lib/c/barbaz.js'),
        () => {
          //addPlugin(nodePlugin);
          rewiremock('./baz')
            .with(() => 'mock')
            .directChildOnly();
        })
        .then(mocked => expect(mocked()).to.be.equal('>+!mock'));
    });
  });

  describe('called from a mock', () => {
    it('should mock top level entity only due to mocked parent: ', () => {
      return rewiremock.around(() => require('./lib/c/barbaz.js'),
        () => {
          //addPlugin(nodePlugin);
          rewiremock('./baz')
            .with(() => 'mock')
            .calledFromMock();
        })
        .then(mocked => expect(mocked()).to.be.equal('>+!mock'));
    });

    it('should everything due to always: ', () => {
      return rewiremock.around(() => require('./lib/c/barbaz.js'),
        () => {
          //addPlugin(nodePlugin);
          rewiremock('./baz')
            .with(() => 'mock')
            .always()
            .calledFromMock();
        })
        .then(mocked => expect(mocked()).to.be.equal('>+mockmock'));
    });

    it('should mock all due to callThrough mocked / async : ', () => {
      return rewiremock.around(() => require('./lib/c/barbaz.js'),
        () => {
          //addPlugin(nodePlugin);
          rewiremock(() => import('./lib/c/bar'))
            .callThrough();
          rewiremock(() => import('./lib/c/baz'))
            .with(() => 'mock')
            .calledFromMock();
        })
        .then(mocked => expect(mocked()).to.be.equal('>+mockmock'));
    });

    it('should mock only direct child due to callThrough mocked / async : ', () => {
      return rewiremock.around(() => require('./lib/c/barbaz.js'),
        () => {
          //addPlugin(nodePlugin);
          rewiremock(() => import('./lib/c/bar'))
            .callThrough();
          rewiremock(() => import('./lib/c/baz'))
            .with(() => 'mock')
            .directChildOnly()
            .calledFromMock();
        })
        .then(mocked => expect(mocked()).to.be.equal('>+!mock'));
    });

    it('should mock all due to callThrough mocked / sync: ', () => {
      return rewiremock.around(() => require('./lib/c/barbaz.js'),
        () => {
          //addPlugin(nodePlugin);
          rewiremock('./baz')
            .with(() => 'mock')
            .calledFromMock();
          rewiremock('./bar')
            .callThrough();
        })
        .then(mocked => expect(mocked()).to.be.equal('>+mockmock'));
    });
  });

  describe('mock through', () => {
    it('should mock through - default', () => {
      return rewiremock.around(() => require('./lib/requireThrough'),
        () => {
          rewiremock('./through')
            .mockThrough();
        })
        .then(mocked => {
          expect(mocked.fun1()).to.be.equal();
          expect(mocked.fun2()).to.be.equal();
          expect(mocked.value1).to.be.equal(41);
          expect(mocked.object.value2).to.be.equal(42);
          expect(mocked.object.fun3()).to.be.equal();
        });
    });

    it('should mock through - inline', () => {
      return rewiremock.around(() => require('./lib/requireThrough'),
        () => {
          rewiremock('./through')
            .mockThrough(() => () => 'mocked');
        })
        .then(mocked => {
          expect(mocked.fun1()).to.be.equal('mocked');
          expect(mocked.fun2()).to.be.equal('mocked');
          expect(mocked.value1).to.be.equal(41);
          expect(mocked.object.fun3()).to.be.equal('mocked');
        });
    });

    it('should mock through - inline and merge', () => {
      return rewiremock.around(() => require('./lib/requireThrough'),
        () => {
          rewiremock('./through')
            .mockThrough(() => () => 'mocked')
            .with({fun2: 42})
        })
        .then(mocked => {
          expect(mocked.fun1()).to.be.equal('mocked');
          expect(mocked.fun2).to.be.equal(42);
        });
    });

    it('should mock through - global', () => {
      return rewiremock.around(() => require('./lib/requireThrough'),
        () => {
          rewiremock.stubFactory((name) => () => name);
          rewiremock('./through').mockThrough();
        })
        .then(mocked => {
          expect(mocked.fun1()).to.be.equal('fun1');
          expect(mocked.fun2()).to.be.equal('fun2');
          expect(mocked.value1).to.be.equal(41);
          expect(mocked.object.fun3()).to.be.equal('object.fun3');
        });
    });

    it('should mock through - instant rewire', () => {
      rewiremock('./lib/through').mockThrough();
      rewiremock.inScope(() => {
        rewiremock.enable();
        rewiremock.stubFactory((name) => () => name);
        const mocked = require('./lib/through');
        rewiremock.disable();
        expect(mocked.fun1()).to.be.equal('fun1');
      });
    });

    it('should mock through - sinon', () => {
      const stub = sinon.stub();
      return rewiremock.around(() => require('./lib/requireThrough'),
        () => {
          rewiremock.stubFactory((name) => name === 'fun1' ? stub : sinon.stub());
          rewiremock('./through').mockThrough();
        })
        .then(mocked => {
          expect(stub.called).to.be.false;
          mocked.fun1();
          expect(stub.called).to.be.true;
          expect(mocked.fun1.called).to.be.true;

          expect(mocked.fun2.called).to.be.false;
          mocked.fun2();
          expect(mocked.fun2.called).to.be.true;
        });
    })
  });

});
